# -*- coding: utf-8 -*-
"""NSGA II parallel

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cb2gVHoma5h3IVA_NEaN88X5k9kIjdJm
"""

import pandas as pd
import random

# === Load the dataset using file path ===
file_path = "/content/lawyers_with_estimated_price.csv"  # Replace with your actual path
df = pd.read_csv(file_path)

# === Genetic Algorithm Parameters ===
POPULATION_SIZE = 30
GENERATIONS = 50
MUTATION_RATE = 0.1
TOURNAMENT_SIZE = 5

# === Fitness Function ===
def compute_fitness(individual, df, budget):
    exp_norm = (individual["Years of active experience"] - df["Years of active experience"].min()) / \
               (df["Years of active experience"].max() - df["Years of active experience"].min() + 1e-6)
    fav_norm = (individual["No of favoured settlements"] - df["No of favoured settlements"].min()) / \
               (df["No of favoured settlements"].max() - df["No of favoured settlements"].min() + 1e-6)
    sat_norm = (individual["Client satisfaction (out of 10)"] - df["Client satisfaction (out of 10)"].min()) / \
               (df["Client satisfaction (out of 10)"].max() - df["Client satisfaction (out of 10)"].min() + 1e-6)
    price_prox_norm = 1 - ((budget - individual["Price"]) / (budget + 1e-6)) if individual["Price"] <= budget else 0

    fitness = 0.3 * exp_norm + 0.3 * fav_norm + 0.2 * sat_norm + 0.2 * price_prox_norm
    return fitness

# === Initialize Population ===
def initialize_population(candidates):
    unique_candidates = candidates.drop_duplicates(subset=["Name"])
    sampled = unique_candidates.sample(n=min(POPULATION_SIZE, len(unique_candidates)), replace=False)
    return list(sampled.to_dict(orient="records"))

# === Tournament Selection ===
def selection(population, df, budget):
    tournament = random.sample(population, min(TOURNAMENT_SIZE, len(population)))
    return max(tournament, key=lambda ind: compute_fitness(ind, df, budget))

# === Crossover ===
def crossover(parent1, parent2):
    child = {}
    for key in parent1:
        child[key] = parent1[key] if random.random() < 0.5 else parent2[key]
    return child

# === Mutation ===
def mutate(individual, candidates):
    if random.random() < MUTATION_RATE:
        mutation_candidate = random.choice(candidates.to_dict(orient="records"))
        mutation_field = random.choice([
            "Years of active experience",
            "No of favoured settlements",
            "Client satisfaction (out of 10)",
            "Price"
        ])
        individual[mutation_field] = mutation_candidate[mutation_field]
    return individual

# === Run the GA and Rank Results ===
def run_genetic_algorithm(domain, budget):
    # Filter by domain and budget
    candidates = df[(df["Domain"] == domain) & (df["Price"] <= budget)].copy()
    if candidates.empty:
        print("No matching candidates found.")
        return pd.DataFrame()

    # Initialize population (optional: use in further GA evolution)
    population = initialize_population(candidates)

    for _ in range(GENERATIONS):
        new_population = []
        while len(new_population) < POPULATION_SIZE:
            parent1 = selection(population, df, budget)
            parent2 = selection(population, df, budget)
            child = crossover(parent1, parent2)
            child = mutate(child, candidates)
            new_population.append(child)
        population = new_population

    # Evaluate all valid candidates for final display
    all_candidates = candidates.copy()
    all_candidates["Fitness Score"] = all_candidates.apply(lambda row: compute_fitness(row, df, budget), axis=1)

    # Sort by Fitness (descending), then Price (ascending)
    sorted_candidates = all_candidates.sort_values(
        by=["Fitness Score", "Price"], ascending=[False, True]
    ).drop_duplicates(subset="Name").reset_index(drop=True)

    return sorted_candidates

# === Run Demo ===
domain_input = "Tax Law"    # 👈 Change this
budget_input = 30000        # 👈 And this

top_lawyers = run_genetic_algorithm(domain_input, budget_input)

# === Display Results ===
top_lawyers[[
    "Name", "Domain", "Price", "Years of active experience",
    "No of favoured settlements", "Client satisfaction (out of 10)", "Fitness Score"
]]

!pip install pymoo

!pip install pymoo==0.5.0

!pip install pymoo --upgrade

!pip install pymoo --upgrade

import pandas as pd
import numpy as np
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.optimize import minimize
from pymoo.termination import get_termination
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM

# === Load your dataset ===
file_path = "/content/lawyers_with_estimated_price.csv"
df = pd.read_csv(file_path)

# === Filter dataset ===
domain_input = "Tax Law"
budget_input = 30000
filtered_df = df[(df["Domain"] == domain_input) & (df["Price"] <= budget_input)].reset_index(drop=True)

# === Define NSGA-II Optimization Problem ===
class LawyerSelectionProblem(Problem):
    def __init__(self, df):
        self.df = df.reset_index(drop=True)
        super().__init__(n_var=len(df), n_obj=4, n_constr=0, xl=0.0, xu=1.0)

    def _evaluate(self, X, out, *args, **kwargs):
        objs = []
        for weights in X:
            weights = np.clip(weights, 0, 1)
            weights /= np.sum(weights) + 1e-6  # normalize weights

            # Weighted profile
            profile = (self.df[[
                "Years of active experience",
                "No of favoured settlements",
                "Client satisfaction (out of 10)",
                "Price"
            ]].T @ weights).values

            objs.append([
                -profile[0],  # maximize experience
                -profile[1],  # maximize settlements
                -profile[2],  # maximize satisfaction
                profile[3]    # minimize price
            ])
        out["F"] = np.array(objs)

# === Initialize and run NSGA-II ===
problem = LawyerSelectionProblem(filtered_df)

algorithm = NSGA2(
    pop_size=50,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(eta=20),
    eliminate_duplicates=True
)

termination = get_termination("n_gen", 100)

res = minimize(problem, algorithm, termination, seed=1, verbose=False)

# === Extract top individuals ===
top_lawyers = []
for i, weights in enumerate(res.X):
    weights = np.clip(weights, 0, 1)
    weights /= np.sum(weights) + 1e-6
    idx = np.argmax(weights)
    lawyer = filtered_df.iloc[idx].to_dict()
    lawyer["Objective Vector"] = res.F[i]
    lawyer["Price Objective"] = res.F[i][3]  # For sorting later
    top_lawyers.append(lawyer)

# === Display top results ===
result_df = pd.DataFrame(top_lawyers).drop_duplicates(subset=["Name"])
result_df = result_df.sort_values(by="Price Objective").reset_index(drop=True)

# === Show Relevant Columns ===
result_df[[
    "Name", "Domain", "Price", "Years of active experience",
    "No of favoured settlements", "Client satisfaction (out of 10)", "Price Objective"
]]

import pandas as pd
import numpy as np
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.optimize import minimize
from pymoo.termination import get_termination
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM

# === Load your dataset ===
file_path = "/content/lawyers_with_estimated_price.csv"
df = pd.read_csv(file_path)

# === Filter dataset ===
domain_input = "Tax Law"       # 👈 Change domain as needed
budget_input = 30000           # 👈 Set your budget limit
filtered_df = df[(df["Domain"] == domain_input) & (df["Price"] <= budget_input)].reset_index(drop=True)

# === Define NSGA-II Optimization Problem ===
class LawyerSelectionProblem(Problem):
    def __init__(self, df):
        self.df = df.reset_index(drop=True)
        super().__init__(n_var=len(df), n_obj=4, n_constr=0, xl=0.0, xu=1.0)

    def _evaluate(self, X, out, *args, **kwargs):
        objs = []
        for weights in X:
            weights = np.clip(weights, 0, 1)
            weights /= np.sum(weights) + 1e-6  # normalize weights

            profile = (self.df[[
                "Years of active experience",
                "No of favoured settlements",
                "Client satisfaction (out of 10)",
                "Price"
            ]].T @ weights).values

            objs.append([
                -profile[0],  # maximize experience
                -profile[1],  # maximize settlements
                -profile[2],  # maximize satisfaction
                profile[3]    # minimize price
            ])
        out["F"] = np.array(objs)

# === Initialize and run NSGA-II ===
problem = LawyerSelectionProblem(filtered_df)

algorithm = NSGA2(
    pop_size=50,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(eta=20),
    eliminate_duplicates=True
)

termination = get_termination("n_gen", 100)

res = minimize(problem, algorithm, termination, seed=1, verbose=False)

# === Extract top individuals ===
top_lawyers = []
for i, weights in enumerate(res.X):
    weights = np.clip(weights, 0, 1)
    weights /= np.sum(weights) + 1e-6
    idx = np.argmax(weights)
    lawyer = filtered_df.iloc[idx].to_dict()
    lawyer["Objective Vector"] = res.F[i]
    lawyer["Price Objective"] = res.F[i][3]  # For sorting
    top_lawyers.append(lawyer)

# === Display all attributes ===
result_df = pd.DataFrame(top_lawyers).drop_duplicates(subset=["Name"])
result_df = result_df.sort_values(by="Price Objective").reset_index(drop=True)

# Show all columns in output
pd.set_option("display.max_columns", None)
display(result_df)

import matplotlib.pyplot as plt
from pymoo.util.nds.non_dominated_sorting import NonDominatedSorting

# Get the objective vectors (negated values were used for maximization)
F = res.F

# Extract two objectives to plot (e.g., experience vs. satisfaction)
x = -F[:, 0]  # experience (was negated to maximize)
y = -F[:, 2]  # satisfaction (was negated to maximize)

# Find Pareto-optimal solutions (non-dominated front)
nd_front = NonDominatedSorting().do(F, only_non_dominated_front=True)

# Plot all solutions
plt.figure(figsize=(8, 5))
plt.scatter(x, y, color='blue', s=10, label='Solution')

# Plot Pareto-optimal solutions
plt.scatter(x[nd_front], y[nd_front], color='red', s=40, marker='v', label='Pareto Solution')

plt.xlabel("Experience Score")
plt.ylabel("Client Satisfaction Score")
plt.legend()
plt.grid(True)
plt.title("NSGA-II Lawyer Selection: Experience vs Satisfaction")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from pymoo.util.nds.non_dominated_sorting import NonDominatedSorting

# === Blue Dots: Raw Lawyers Data (within budget & domain) ===
x_blue = filtered_df["Price"].values
y_blue = filtered_df["Client satisfaction (out of 10)"].values

# === Red Dots: NSGA-II Pareto-optimal solutions ===
F = res.F
nd_indices = NonDominatedSorting().do(F, only_non_dominated_front=True)

# Extract price (minimize) and satisfaction (maximize, so we invert)
x_pareto = F[nd_indices, 3]       # Price (no negation — already to minimize)
y_pareto = -F[nd_indices, 2]      # Satisfaction (negated in obj, so invert back)

# Sort by price for smooth Pareto front line
sorted_idx = np.argsort(x_pareto)
x_pareto_sorted = x_pareto[sorted_idx]
y_pareto_sorted = y_pareto[sorted_idx]

# === Plotting ===
plt.figure(figsize=(8, 5))

# Raw filtered lawyers
plt.scatter(x_blue, y_blue, s=10, c='blue', label='Solution')

# NSGA-II Pareto front
plt.scatter(x_pareto_sorted, y_pareto_sorted, s=40, c='red', marker='v', label='Pareto Solution')

plt.xlabel("Price")
plt.ylabel("Client Satisfaction Score")
plt.title("NSGA-II Lawyer Selection: Price vs Satisfaction")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Parallel MPI Code

"""

!pip install mpi4py

# === Imports ===
import pandas as pd
import numpy as np
from mpi4py import MPI
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.optimize import minimize
from pymoo.termination import get_termination
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM

# === MPI Setup ===
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

# === Load Dataset (all ranks need it) ===
file_path = "/content/lawyers_with_estimated_price.csv"
df = pd.read_csv(file_path)

# === Filter Dataset ===
domain_input = "Tax Law"  # Change as needed
budget_input = 30000      # Change as needed
filtered_df = df[(df["Domain"] == domain_input) & (df["Price"] <= budget_input)].reset_index(drop=True)

# === Problem Definition ===
class LawyerSelectionProblem(Problem):
    def __init__(self, df):
        self.df = df.reset_index(drop=True)
        super().__init__(n_var=len(df), n_obj=4, n_constr=0, xl=0.0, xu=1.0)

    def _evaluate(self, X, out, *args, **kwargs):
        objs = []
        for weights in X:
            weights = np.clip(weights, 0, 1)
            weights /= np.sum(weights) + 1e-6  # Normalize
            profile = (self.df[[
                "Years of active experience",
                "No of favoured settlements",
                "Client satisfaction (out of 10)",
                "Price"
            ]].T @ weights).values
            objs.append([
                -profile[0],  # Maximize experience
                -profile[1],  # Maximize settlements
                -profile[2],  # Maximize satisfaction
                profile[3]    # Minimize price
            ])
        out["F"] = np.array(objs)

# === Run Optimization ===
problem = LawyerSelectionProblem(filtered_df)

algorithm = NSGA2(
    pop_size=50,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(eta=20),
    eliminate_duplicates=True
)

termination = get_termination("n_gen", 100)
local_seed = 42 + rank

res = minimize(problem, algorithm, termination, seed=local_seed, verbose=(rank == 0))

# === Gather Results to Root ===
all_results = comm.gather(res, root=0)

# === Process and Display Final Output on Root ===
if rank == 0:
    top_lawyers = []
    for res in all_results:
        for i, weights in enumerate(res.X):
            weights = np.clip(weights, 0, 1)
            weights /= np.sum(weights) + 1e-6
            idx = np.argmax(weights)
            lawyer = filtered_df.iloc[idx].to_dict()
            lawyer["Objective Vector"] = res.F[i]
            lawyer["Experience Score"] = -res.F[i][0]
            lawyer["Settlements Score"] = -res.F[i][1]
            lawyer["Satisfaction Score"] = -res.F[i][2]
            lawyer["Price Objective"] = res.F[i][3]
            top_lawyers.append(lawyer)

    # Final DataFrame
    result_df = pd.DataFrame(top_lawyers).drop_duplicates(subset=["Name"])
    result_df = result_df.sort_values(by="Price Objective").reset_index(drop=True)

    # Display Recommendations
    print("\n🔍 Top Lawyer Recommendations:\n")
    display_cols = [
        "Name", "Domain", "Years of active experience",
        "No of favoured settlements", "Client satisfaction (out of 10)",
        "Price", "Experience Score", "Settlements Score", "Satisfaction Score", "Price Objective"
    ]
    print(result_df[display_cols].to_string(index=False))

    # Summary Metrics
    print("\n📊 Summary Metrics:")
    print(f"✅ Number of Recommended Lawyers : {len(result_df)}")
    avg_scores = result_df[["Experience Score", "Settlements Score", "Satisfaction Score"]].mean()
    print(f"📈 Avg Experience Score         : {avg_scores['Experience Score']:.2f}")
    print(f"📈 Avg Settlements Score        : {avg_scores['Settlements Score']:.2f}")
    print(f"📈 Avg Satisfaction Score       : {avg_scores['Satisfaction Score']:.2f}")
    print(f"💰 Price Range                  : ₹{result_df['Price'].min():,.0f} - ₹{result_df['Price'].max():,.0f}")

    # Save to CSV
    result_df.to_csv("recommended_lawyers.csv", index=False)
    print("\n💾 Saved output to 'recommended_lawyers.csv'")

import time
import numpy as np
from pymoo.core.callback import Callback

# Create a custom callback to track generation timing
class TimingCallback(Callback):
    def __init__(self):
        super().__init__()
        self.times = []
        self.start_time = None

    def notify(self, algorithm):
        current_time = time.time()
        if self.start_time is None:
            self.start_time = current_time
        elapsed = current_time - self.start_time
        self.times.append(elapsed)
        self.start_time = current_time

# Use in your optimization
timing_callback = TimingCallback()

res = minimize(
    problem,
    algorithm,
    termination,
    seed=1,
    verbose=True,
    callback=timing_callback
)

# After run: get cumulative or per-gen timings
per_gen_times = timing_callback.times
print("Execution time per generation (seconds):")
for gen, t in enumerate(per_gen_times):
    print(f"Gen {gen+1}: {t:.4f} s")

import matplotlib.pyplot as plt
generations = list(range(1, len(per_gen_times) + 1))
plt.plot(generations, per_gen_times, marker='o')
plt.xlabel("Generation")
plt.ylabel("Execution Time (s)")
plt.title("NSGA-II: Per Generation Execution Time")
plt.grid(True)
plt.show()

from pymoo.core.callback import Callback
import time

class TimingCallback(Callback):
    def __init__(self):
        super().__init__()
        self.times = []
        self.start_time = None

    def notify(self, algorithm):
        current_time = time.time()
        if self.start_time is None:
            self.start_time = current_time
        elapsed = current_time - self.start_time
        self.times.append(elapsed)
        self.start_time = current_time

callback = TimingCallback()
res = minimize(problem, algorithm, termination, seed=1, callback=callback)

seq_times = callback.times

from mpi4py import MPI
from pymoo.core.callback import Callback
import time
import numpy as np

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

class MPITimingCallback(Callback):
    def __init__(self):
        super().__init__()
        self.times = []
        self.start_time = None

    def notify(self, algorithm):
        current_time = time.time()
        if self.start_time is None:
            self.start_time = current_time
        elapsed = current_time - self.start_time
        self.start_time = current_time
        # Only rank 0 collects
        if rank == 0:
            self.times.append(elapsed)

callback = MPITimingCallback()

if rank == 0:
    print("Running optimization on rank 0...")

res = minimize(problem, algorithm, termination, seed=1, callback=callback)

# After optimization (only on rank 0)
if rank == 0:
    mpi_times = callback.times
    print("MPI Execution time per generation:")
    for gen, t in enumerate(mpi_times):
        print(f"Gen {gen+1}: {t:.4f} s")

if rank == 0:
    generations = list(range(1, len(seq_times) + 1))
    plt.figure(figsize=(10, 6))
    plt.plot(generations, seq_times, label="Sequential", marker='o')
    plt.plot(generations, mpi_times, label="MPI Parallel", marker='s')
    plt.xlabel("Generation")
    plt.ylabel("Time (seconds)")
    plt.title("NSGA-II Execution Time Per Generation")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

!pip install pymoo --upgrade

from pymoo.indicators.hv import HV
from pymoo.core.callback import Callback
import numpy as np

class AccuracyCallback(Callback):
    def __init__(self, ref_point):
        super().__init__()
        self.hypervolumes = []
        self.ref_point = np.array(ref_point)

    def notify(self, algorithm):
        F = algorithm.pop.get("F")
        hv = HV(ref_point=self.ref_point)
        self.hypervolumes.append(hv(F))

ref_point = [0, 0, 0, 50000]  # Choose a reference point worse than any real solution
callback = AccuracyCallback(ref_point=ref_point)

res = minimize(problem, algorithm, termination, seed=1, callback=callback)

acc_callback_mpi = AccuracyCallback(ref_point)
res_mpi = minimize(problem, algorithm, termination, seed=1, callback=acc_callback_mpi)
if rank == 0:
    mpi_hv = acc_callback_mpi.hypervolumes

import matplotlib.pyplot as plt

generations = list(range(1, len(callback.hypervolumes) + 1))

plt.plot(generations, callback.hypervolumes, marker='o', label="Hypervolume")
plt.plot(generations, mpi_hv, marker='s', label="MPI NSGA-II")

plt.xlabel("Generation")
plt.ylabel("Hypervolume")
plt.title("Pareto Front Accuracy (Hypervolume) Over Generations")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()